"use strict";

var utilsMock = _interopRequireWildcard(require("../../utils"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

jest.mock('../../utils', () => _extends({}, require.requireActual('../../utils'), {
  isOptedOut: jest.fn((key, t) => t)
}));
afterEach(() => {
  jest.resetModules();
});
test('includes format and git add when not opted out', () => {
  utilsMock.isOptedOut.mockImplementation((key, t, f) => f);

  const config = require('../lintstagedrc');

  const jsLinter = getJsLinter(config.linters);
  expect(hasFormat(jsLinter)).toBe(true);
  expect(hasGitAdd(jsLinter)).toBe(true);
});
test('does not include format and git add when opted out', () => {
  utilsMock.isOptedOut.mockImplementation((key, t) => t);

  const config = require('../lintstagedrc');

  const jsLinter = getJsLinter(config.linters);
  expect(hasFormat(jsLinter)).toBe(false);
  expect(hasGitAdd(jsLinter)).toBe(false);
});

function hasFormat(linter) {
  return linter.some(l => l.includes('format'));
}

function hasGitAdd(linter) {
  return linter.includes('git add');
}

function getJsLinter(linters) {
  const key = Object.keys(linters).find(k => k.includes('**') && k.includes('js'));
  return linters[key];
}